use std::collections::HashMap;

pub(crate) fn product_of_joltage_diff_1_and_3_counts(numbers: &[String]) -> usize {
    let numbers = add_start_and_end_then_sort(numbers);
    let diffs = diffs_between(&numbers);
    let count_of_1 = diffs.iter().filter(|&&n| n == 1).count();
    let count_of_3 = diffs.iter().filter(|&&n| n == 3).count();
    count_of_1 * count_of_3
}

pub(crate) fn adapter_combination_count(numbers: &[String]) -> usize {
    let numbers = add_start_and_end_then_sort(numbers);
    let diffs = diffs_between(&numbers);
    // There are only diffs of one and three, but no diffs of two.
    // From these, only the diffs of one allow multiple configurations, see below
    let cluster_count_by_length = total_number_of_1_clusters_by_length(diffs);
    // println!("tuple_count_by_size = {:?}", cluster_count_by_length);
    let mut product = 1;
    for (cluster_length, cluster_count) in cluster_count_by_length {
        let combinations_per_cluster = number_of_combinations_per_cluster_of_length(cluster_length);
        product *= combinations_per_cluster.pow(cluster_count as u32);
    }
    product
}

// Calculate the number of combinations per number of consecutive 1s ("length" or "cluster size")
// Length 1 allows no options: 1
// Length 2 has 2 combinations: 11 and 2 (note: 2 is the contraction of 11)
// Length 3 has 4 combinations: 111, 21 (note: same as above 2 with 1 appended),
//                              as well as 12 and 3 (both contractions of 111)
// Length 3 has 7 combinations: 1111, 211, 121, 31 (note: same as above 4 with 1 appended)
//                              as well as 112, 22 and 13 (again: contractions of 1111)
//
// Because of the way these combinations can be constructed from previous shorter clusters,
// there is structure to this process:
// The most plentiful combinations always end in a 1, as they are generated by simply appending a 1
// to _all_ the previous options.
// There are fewer combinations ending in 2 (coming from adding two 1s next to each other),
// and fewer still ending in 3 (contraction of 2 and 1 next to each other)
//
// This table shows the pattern well:
// len: tot = 3s + 2s + 1s
// -----------------------
//   1:   1 =  0 +  0 +  1
//   2:   2 =  0 +  1 +  1
//   3:   4 =  1 +  1 +  2
//   4:   7 =  1 +  2 +  4
//   5:  13 =  2 +  4 +  7
//   6:  23 =  4 +  7 + 12
fn number_of_combinations_per_cluster_of_length(n: usize) -> usize {
    match n {
        0 => unreachable!(),
        1..=2 => n,
        3 => 4,
        n => {
            number_of_combinations_per_cluster_of_length(n - 1) // number of 1s
            + number_of_combinations_per_cluster_of_length(n - 2) // number of 2s
            + number_of_combinations_per_cluster_of_length(n - 3) // number of 3s
        } // number of 3s
    }
}

fn total_number_of_1_clusters_by_length(diffs: Vec<usize>) -> Vec<(usize, usize)> {
    let mut cluster_count_by_length: HashMap<usize, usize> = HashMap::new();
    let mut cluster_length = 1;
    for (idx, number) in diffs.iter().enumerate().take(diffs.len() - 1) {
        if *number == 1 && diffs[idx + 1] == 1 {
            cluster_length += 1;
        } else if cluster_length > 1 {
            *cluster_count_by_length.entry(cluster_length).or_insert(0) += 1;
            cluster_length = 1;
        }
    }
    let mut cluster_count_by_length: Vec<(_, _)> = cluster_count_by_length.into_iter().collect();
    cluster_count_by_length.sort_unstable();
    cluster_count_by_length
}

fn add_start_and_end_then_sort(numbers: &[String]) -> Vec<usize> {
    let mut numbers: Vec<_> = numbers.iter().map(|s| s.parse().unwrap()).collect();
    numbers.push(0); // outlet
    numbers.push(*numbers.iter().max().unwrap() + 3); // input
    numbers.sort_unstable();
    // println!("sorted = {:?}", numbers);
    numbers
}

fn diffs_between(numbers: &[usize]) -> Vec<usize> {
    let diffs: Vec<_> = numbers
        .iter()
        .zip(numbers.iter().skip(1))
        .map(|(a, b)| b - a)
        .collect();
    // println!(" diffs = {:?}", diffs);
    diffs
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::line_reader::{read_file_to_lines, read_str_to_lines};

    const EXAMPLE_1: &str = "16
10
15
5
1
11
7
19
6
12
4";

    const EXAMPLE_2: &str = "28
33
18
42
31
14
46
20
48
47
24
23
49
45
19
38
39
11
1
32
25
35
8
17
7
9
4
2
34
10
3";

    #[test]
    fn part1_example_1() {
        assert_eq!(
            product_of_joltage_diff_1_and_3_counts(&read_str_to_lines(EXAMPLE_1)),
            7 * 5
        );
    }

    #[test]
    fn part1_example_2() {
        assert_eq!(
            product_of_joltage_diff_1_and_3_counts(&read_str_to_lines(EXAMPLE_2)),
            22 * 10
        );
    }

    #[test]
    fn part1() {
        assert_eq!(
            product_of_joltage_diff_1_and_3_counts(&read_file_to_lines("input/day10.txt")),
            2080
        );
    }

    #[test]
    fn part2_example_1() {
        assert_eq!(
            adapter_combination_count(&read_str_to_lines(EXAMPLE_1)),
            4 * 2
        );
    }

    #[test]
    fn part2_example_2() {
        assert_eq!(
            adapter_combination_count(&read_str_to_lines(EXAMPLE_2)),
            19208
        );
    }

    #[test]
    fn part2() {
        assert_eq!(
            adapter_combination_count(&read_file_to_lines("input/day10.txt")),
            6908379398144
        );
    }
}
